---
title: 签名
---

比特币中的签名数据是通过私钥对交易数据进行 `ECDSA` 或 `Schnorr` 签名生成的, 签名数据被放置在交易的 `scriptSig` 或 `witness` 字段中。目的是为了在脚本执行时, 通过 `OP_CHECKSIG` 等操作码的检查, 以确认是否可以花费该 `UTXO`。

交易的签名针对的是特定的交易输入, 多个交易输入需要多个签名。

## 未签名交易

构造未签名交易时, 需要提供:

- 交易输入

  - `txid` - 要花费的 `UTXO` 来自于哪个交易ID
  - `vout` - 要花费的 `UTXO` 来自于交易输出的哪个索引号

- 交易输出

  - `amount` - 输出的聪的数量
  - `scriptPubKey` - 锁定脚本。根据接收地址生成的锁定脚本。

<UnSignTransactionBuilder />

## 签名

比特币中签名指的是计算交易中 `ScriptSig` 或 `Witness` 字段的签名数据, 主要用来验证交易的合法性。

签名针对的是特定的交易输入, 不同的交易输入的锁定脚本类型具有不同的签名过程, 但总体上都需要经历下面的步骤:

- 构造未签名数据
- 添加哈希类型
- 数据签名
- DER 编码
- 解锁脚本

:::warning

非隔离见证交易不可花费隔离见证 `UTXO`, 但隔离见证交易可以花费非隔离见证 `UTXO`。

具体表现为非隔离见证的交易输入不能是 `P2WPKH`、`P2WSH`、`P2TR` 类型, 但隔离见证的交易输入可以是 `P2PKH`、`P2SH`、`P2MS` 类型。

:::

### 1. 构造未签名数据

对不同的类型的 `UTXO` 锁, 则有不同的构造未签名数据的过程。

#### 非隔离见证锁

非隔离见证锁有 `P2PKH`、`P2SH`、`P2MS`。

当要签名的交易输入的 `UTXO` 锁是非隔离见证锁时, 则需要将 `scriptSig` 字段临时替换为 `UTXO` 的 `scriptPubKey` 字段, 其他交易输入的 `scriptSig` 字段保持为空。

例如有如下交易时:

<TransactionSplitTab hex='02000000020323f0c5cdd3408336cd7e6b6df9cf0ccde996f363b64a066497a5a60c44f7e40000000000ffffffffcd048bf2054b6885f29246ed1ae55c0e329ed3f0ccaa2d597c6b99b0ed3b97160000000000ffffffff016400000000000000225120b2049a6d884575fe95e3fcaeaedae4ec4feaecccc30fad156f12923753c0954e00000000' />

要签名的第 0 个交易输入的 `UTXO` 锁是 `P2PKH` 类型, 将 `scriptSig` 字段替换为 `scriptPubKey` 字段后为

<TransactionSplitTab hex='02000000020323f0c5cdd3408336cd7e6b6df9cf0ccde996f363b64a066497a5a60c44f7e4000000001976a914c189d7f7ea4333daec66a645cb3388163c22900b88acffffffffcd048bf2054b6885f29246ed1ae55c0e329ed3f0ccaa2d597c6b99b0ed3b97160000000000ffffffff016400000000000000225120b2049a6d884575fe95e3fcaeaedae4ec4feaecccc30fad156f12923753c0954e00000000' />

`scriptSigSize` 也要同步更新。

#### 隔离见证V0

隔离见证V0锁有 `P2WPKH`、`P2WSH`、`P2SH-P2WSH`。

[BIP143](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki) 定义了隔离见证交易的签名规则, 如果要签名的交易输入的 `UTXO` 锁是隔离见证V0类型 则首先需要分别计算下列数据:

- `hashPrevouts` - 所有交易输入的 `txid` 和 `vout` 拼接后进行 `Hash256` 计算
- `hashSequence` - 所有交易输入的 `sequence` 拼接后进行 `Hash256` 计算
- `hashOutputs` - 所有交易输出的 `amount`、`scriptPubKeySize` 和 `scriptPubKey` 拼接后进行 `Hash256` 计算

其次依次拼接:

1. 交易的版本号 `version`
2. `hashPrevouts`
3. `hashSequence`
4. 要签名的交易输入的`txid`
5. 要签名的交易输入的`vout`
6. `scriptCode` 的字节大小
7. `scriptCode`: 如果是 `P2WPKH` 锁, 则提取出公钥哈希转换为 `P2PKH` 锁定脚本作为 `scriptCode`; 如果是 `P2WSH` 锁, 则提取出 `redeemScript` 作为 `scriptCode`
8. 花费的 `UTXO` 的金额
9. 要签名的交易输入的`sequence`
10. `hashOutputs`
11. 交易的 `lockTime`

#### 隔离见证V1

隔离见证V1锁有 `P2TR`。

[BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki) 定义了 `Taproot` 签名规则, 如果要签名的交易输入的 `UTXO` 锁是 `P2TR`, 则首先需要分别计算下列数据:

- `hashPrevouts`
- `hashAmounts`
- `hashScriptPubKeys`
- `hashSequences`
- `hashOutputs`

:::danger 签名私钥

`P2TR` 签名的私钥并非原始私钥(内部私钥), 而是 `Taproot` 私钥, 也称 `Tweaked Private Key`。

`Taproot` 私钥等于原始私钥加上 `tweak` 值。

```ts
const keyPair = ECPair.fromWIF(process.env['SECRET_KEY']!, network)

function tweakSigner(signer: Signer, opts: any = {}): Signer {
  let privateKey: Uint8Array | undefined = signer.privateKey!
  if (!privateKey) {
    throw new Error('Private key is required for tweaking signer!')
  }
  if (signer.publicKey[0] === 3) {
    privateKey = ecc.privateNegate(privateKey)
  }

  const tweakedPrivateKey = ecc.privateAdd(
    privateKey,
    tapTweakHash(toXOnly(signer.publicKey), opts.tweakHash)
  )
  if (!tweakedPrivateKey) {
    throw new Error('Invalid tweaked private key!')
  }

  return ECPair.fromPrivateKey(tweakedPrivateKey, {
    network
  })
}

function tapTweakHash(pubKey: Buffer, h: Buffer | undefined): Buffer {
  return crypto.taggedHash(
    'TapTweak',
    Buffer.concat(h ? [pubKey, h] : [pubKey])
  )
}
```

:::

#### 非隔离见证交易

<SignedTransactionBuilder hex='02000000030323f0c5cdd3408336cd7e6b6df9cf0ccde996f363b64a066497a5a60c44f7e40000000000ffffffffcd048bf2054b6885f29246ed1ae55c0e329ed3f0ccaa2d597c6b99b0ed3b97160000000000ffffffff161ec3f56a53829f31665ae94c3d1dee3d4a6b5f1096c0a9f84ce46db70c36770000000000ffffffff016400000000000000225120b2049a6d884575fe95e3fcaeaedae4ec4feaecccc30fad156f12923753c0954e00000000' />

<TransactionSplitTab hex='02000000030323f0c5cdd3408336cd7e6b6df9cf0ccde996f363b64a066497a5a60c44f7e40000000000ffffffffcd048bf2054b6885f29246ed1ae55c0e329ed3f0ccaa2d597c6b99b0ed3b97160000000000ffffffff161ec3f56a53829f31665ae94c3d1dee3d4a6b5f1096c0a9f84ce46db70c36770000000000ffffffff016400000000000000225120b2049a6d884575fe95e3fcaeaedae4ec4feaecccc30fad156f12923753c0954e00000000' />

### 2. 添加哈希类型

对上一步生成的交易数据的末尾添加哈希类型 `sighash`, 为小端序 4 字节数据, 用于指定签名的数据。

- `SIGHASH_ALL` - 签名所有输入和输出, 值为 `0x01`
- `SIGHASH_NONE` - 签名所有输入, 但不签名输出, 值为 `0x02`
- `SIGHASH_SINGLE` - 签名所有输入, 但只签名对应的输出, 值为 `0x03`
- `SIGHASH_ANYONECANPAY` - 只签名当前输入, 不签名其他输入和输出, 值为 `0x80`

### 3. 数据签名

对上一步生成的交易数据进行 `Hash256` 计算, 并将运算结果作为 `ECDSA` 签名消息, 使用私钥对消息进行签名, 得到 `r` 和 `s`。

```ts
import ecc from '@bitcoinerlab/secp256k1'
import ECPairFactory from 'ecpair'
import { hash256 } from 'bitcoinjs-lib/src/crypto'

const ECPair = ECPairFactory(ecc)

const keypair = ECPair.fromPrivateKey(Buffer.from(privateKey, 'hex'))
const hashedTransaction = hash256(Buffer.from(waitingForSignTx, 'hex'))

// ecdsa 签名结果
const ecdsaSignature = keypair.sign(hashedTransaction)
```

`ECDSA` 签名结果是一个 `64` 字节的数据, 前 `32` 字节是 `r`, 后 `32` 字节是 `s`。

验证时通过公钥和签名数据计算得到的 `r` 是否与签名数据中的 `r` 相同, 若相同则签名有效。

因此实际的交易中, 凡是用到 `ECDSA` 签名的脚本, 都需要提供公钥。

例如:

- `P2PK` 将公钥存储在锁定脚本中, 解锁脚本只需要包含签名数据
- `P2PKH` 和 `P2WPKH` 将公钥和签名数据都放在解锁脚本中
- `P2MS` 将多签用到的公钥都放在了锁定脚本中

而 `P2TR` 使用 `Schnorr` 签名, 并不需要提供原始公钥, 但仍需要 `Taproot` 公钥。

### 4. DER 编码

`ECDSA` 签名数据需要进行 `DER` 编码, 生成最终的签名数据。

假设 `ECDSA` 签名数据是:

```ts
039d8fcf8bd43c2eba1ca16ad2512e33892994745220464164dd7550886a4f961d056caebb71ab54aedf29143b6416a5e482d3d840c0dab48abbd34efef53032

r=039d8fcf8bd43c2eba1ca16ad2512e33892994745220464164dd7550886a4f96
s=1d056caebb71ab54aedf29143b6416a5e482d3d840c0dab48abbd34efef53032
```

- 在 `r` 和 `s` 前添加类型字节 `0x02` (表示整数) 和长度字节 `0x20`

```text
r:
02 20 039d8fcf8bd43c2eba1ca16ad2512e33892994745220464164dd7550886a4f96

s:
02 20 1d056caebb71ab54aedf29143b6416a5e482d3d840c0dab48abbd34efef53032
```

- 组合 `r` 和 `s` 后并在前添加整体长度字节 `0x44` 和 标识符字节 `0x30`

```text
30440220039d8fcf8bd43c2eba1ca16ad2512e33892994745220464164dd7550886a4f9602201d056caebb71ab54aedf29143b6416a5e482d3d840c0dab48abbd34efef53032
```

- 末尾添加签名使用的哈希类型

```text
30440220039d8fcf8bd43c2eba1ca16ad2512e33892994745220464164dd7550886a4f9602201d056caebb71ab54aedf29143b6416a5e482d3d840c0dab48abbd34efef5303201
```

最终的签名数据大小为 71 字节

### 5. 解锁脚本

根据要花费的 `UTXO` 的锁定脚本类型, 生成解锁脚本放在 `scriptSig` 字段中。

例如要花费的 `UTXO` 是 `P2PKH` 类型, 则解锁脚本格式为:

```text
OP_PUSHBYTES_71 <签名数据> OP_PUSHBYTES_33 <公钥>
```

最后将 `scriptSig` 字段替换为解锁脚本。

## PSBT

BIP174 定义了部分签名交易格式, 用于多签名交易的签名。
