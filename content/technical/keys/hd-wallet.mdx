---
title: HD 钱包
description: Hierarchical Deterministic Wallets
---

分层确定性钱包, 简称 HD 钱包, 是一种可以从单个 `seed` 生成多个密钥对的加密货币钱包系统。

<ScaleableImage
  src='/derive.png'
  alt='taprppt-out-explain'
/>

从 `seed` 生成拓展秘钥, 拓展秘钥又可以派生出多个子拓展秘钥。每个子拓展秘钥又可以继续派生其下层拓展秘钥, 如此往复, 理论上可以无限派生。每个拓展秘钥都可以计算出一个公私钥作为比特币账户。所以 HD 钱包的优点显而易见, 通过一个 `seed` 就可以生成无限多的比特币账号, 且无需备份每个私钥。

## 派生密钥

[BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) 是 HD 钱包的基础, 定义了如何从 `seed` 派生出密钥。

`seed` 是一个随机数, 大小通常是 128 或 256 比特位, 即 16 或 32 字节。通过 `HMAC-SHA512` 哈希函数由 `seed` 生成拓展秘钥(`extended key`), 拓展秘钥由主私钥和链码(`chain code`)组成。

<ExtendedKey />

```ts
import { hmac } from '@noble/hashes/hmac'
import { sha512 } from '@noble/hashes/sha512'

const extendedKey = hmac(sha512, 'Bitcoin seed', Buffer.from(seed, 'hex'))
```

`HMAC-SHA512` 函数的输入是 `seed` 和秘钥字符串([BIP 32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#master-key-generation) 规定这个秘钥字符串是 **Bitcoin seed**), 输出是 64 字节的拓展秘钥(从 `seed` 生成的拓展秘钥也叫主拓展秘钥 `master extended key` )。 前 32 字节作为主私钥, 后 32 字节作为链码。链码作为派生子密钥的秘钥。

拓展秘钥有两种:

- 拓展私钥: 主私钥和链码
- 拓展公钥: 主私钥对应的公钥和链码

```ts
import ecc from '@bitcoinerlab/secp256k1'

// 前32字节为私钥, 后32字节为链码
const privateKey = extendedKey.slice(0, 32)
const chainCode = extendedKey.slice(32)

// 从私钥计算压缩公钥
const publicKey = ecc.pointFromScalar(privateKey, true)

// 拓展私钥
const extendedPrivateKey = extendedKey
// 拓展公钥
const extendedPublicKey = Buffer.concat([publicKey, chainCode])
```

这两种拓展秘钥都能单独的生成子密钥, 从拓展私钥可以派生出**子拓展私钥**, 但从拓展公钥只能派生出**子拓展公钥**。从拓展私钥派生出的子拓展私钥所对应的公钥与拓展公钥派生出的子拓展公钥相同。

拓展秘钥根据索引生成子密钥, 索引大小为 4 字节, 可以表达的最大值是 `4294967295`, 即最多可以派生出 `4294967296` 个子密钥。按照索引值将其分成两种派生方式:

- `Normal Derivation` - 普通派生, 索引范围在 0 - 2147483647:
- `Hardened derivation` - 硬化派生, 索引范围在 2147483648 - 4294967295:

### 普通派生

如果索引小于 `2147483648`, 则为普通派生。

普通派生过程如下:

- 将索引转换为 4 字节的大端字节序
- 将主私钥对应的压缩公钥和索引拼接, 生成 37 字节的数据作为 `HMAC-SHA512` 加密数据
- 将拓展秘钥的链码作为 `HMAC-SHA512` 秘钥
- `HMAC-SHA512` 生成 64 字节的 `I`, 前 32 字节为派生因子, 后 32 字节为子链码
  - 已知父私钥: 派生因子与父私钥相加, 并对椭圆曲线的阶取模, 得到子私钥
  - 仅知道父公钥: 派生因子乘以椭圆曲线的基点并与父公钥相加, 得到子公钥

```ts
import { hmac } from '@noble/hashes/hmac'
import { sha512 } from '@noble/hashes/sha512'
import ecc, { pointAddScalar, privateAdd } from '@bitcoinerlab/secp256k1'
import { fromHex, toHex } from 'uint8array-tools'

// 拓展秘钥的主私钥和链码
const parentPrivateKey = fromHex(extendedKey.slice(0, 64))
const parentChainCode = fromHex(extendedKey.slice(64))

// 10进制索引转换为 4 字节
const index = 0
const indexBuffer = new Uint8Array(4)
new DataView(indexBuffer.buffer).setUint32(0, index, false)

let data: Uint8Array = new Uint8Array()
if (index < 2147483648) {
  // 计算主公钥
  const parentPublicKey = ecc.pointFromScalar(parentPrivateKey, true)

  // 主公钥与索引拼接
  const data = new Uint8Array([...parentPublicKey, ...indexBuffer])
} else {
  // hardened derivation...
}

// HMAC-SHA512 生成 64 字节的 I
const I = hmac(sha512, parentChainCode, data)

const IL = I.slice(0, 32) // 前 32 字节派生因子
const IR = I.slice(32) // 子链码

// 已知父私钥: 与父私钥相加, 并对椭圆曲线的阶取模, 得到子私钥
// 子拓展私钥 = (父私钥 + 派生因子) mod n  || 子链码
const childPrivateKey = privateAdd(parentPrivateKey, IL)

// 仅知道父公钥: 与父公钥相加, 得到子公钥
// 子拓展公钥 = (派生因子 * G + 父公钥点) || 子链码
const childPublicKey = pointFromScalar(childPrivateKey, true)
```

<DeriveSubKey />

子私钥和子链码组合又可以作为拓展秘钥, 继续生成下一级子密钥。

:::danger

普通派生的要求是知道父公钥, 但如果只知道父公钥, 就只能派生出子公钥, 则无法派生出子私钥。

:::

### 硬化派生

如果索引大于等于 `2147483648`, 则为硬化派生。

硬化派生过程如下:

- 将索引转换为 4 字节的大端字节序
- 将主私钥和索引拼接, 最前面补充一个字节 0, 生成 37 字节的数据作为 `HMAC-SHA512` 加密数据
- 将拓展秘钥的链码作为 `HMAC-SHA512` 秘钥
- `HMAC-SHA512` 生成 64 字节的 `I`, 前 32 字节为派生因子, 后 32 字节为子链码, 派生因子与主私钥相加, 并对椭圆曲线的阶取模, 得到子私钥。

```ts
if (index < 2147483648) {
  // normal derivation...
} else {
  // hardened derivation
  data = new Uint8Array([0, ...parentPrivateKey, ...indexBuffer])
}
```

硬化派生与普通派生过程基本一致, 区别在于硬化派生以**主私钥和索引**拼接, 而普通派生则以主私钥对应的**压缩公钥和索引**拼接。

## 秘钥树

通过 `seed` 生成的多层密钥对构成密钥树。

密钥树中的每个节点都是拓展秘钥, 可以用来生成下一级的子秘钥。但拓展秘钥并不能很好的描述节点的信息, 例如节点所在的层级, 节点在所在层的索引, 父秘钥等。因此, 需要定义一种标准格式来描述密钥树中的节点信息。

[BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format) 定义了一种序列化格式, 用于描述密钥树中的节点信息。序列化格式包括:

- 版本号 - 4 字节
  - 主网私钥 - `xprv`(0x0488ADE4), 主网公钥 - `xpub`(0x0488B21E)
  - 测试网私钥 - `tprv`(0x04358394), 测试网公钥 - `tpub`(0x043587CF)
- 深度 - 1 字节, 表示节点在树中的深度
- 父指纹 - 4 字节, 父节点公钥进行 `Hash160` 运算后取前 4 字节作为指纹
- 索引 - 4 字节, 节点在当前层的索引
- 链码 - 32 字节, 拓展秘钥的后 32 字节
- 秘钥 - 33 字节, 压缩公钥或私钥

## 助记词

助记词是 `Seed` 的人类可读形式, 通常是 12 或 24 个单词, 用于恢复钱包。

## 派生路径

BIP32 是 HD 钱包的基础, 它定义了如何从种子生成私钥。BIP44 定义了如何生成地址, 以便在多个钱包之间共享。m/0'/0/0
BIP39 定义了如何生成种子, 以便用户可以记住助记词, 而不是随机的种子。
BIP44 定义了如何生成 P2PKH 地址。m/44'/0'/0'/0/0
BIP49 定义了如何生成 P2SH 地址。m/49'/0'/0'/0/0
BIP84 定义了如何生成 P2WPKH 地址。m/84'/0'/0'/0/0
BIP141 定义了如何生成 P2TR 地址。m/141'/0'/0'/0/0

```ts
import { hmac } from '@noble/hashes/hmac'
import { sha512 } from '@noble/hashes/sha512'
import { bytesToHex, hexToBytes } from '@noble/hashes/utils'
import { secp256k1 } from '@noble/curves/secp256k1'

function deriveChildKey(parentPrivateKey, parentChainCode, index) {
  const indexBuffer = new Uint8Array(4)
  new DataView(indexBuffer.buffer).setUint32(0, index, false)

  let data
  if (index >= 0x80000000) {
    // Hardened child
    data = new Uint8Array([0, ...hexToBytes(parentPrivateKey), ...indexBuffer])
  } else {
    // Normal child
    const parentPublicKey = secp256k1.getPublicKey(
      hexToBytes(parentPrivateKey),
      true
    )
    data = new Uint8Array([...parentPublicKey, ...indexBuffer])
  }

  const I = hmac(sha512, hexToBytes(parentChainCode), data)
  const IL = I.slice(0, 32)
  const IR = I.slice(32)

  // Convert IL to a BigInt and reduce it modulo the curve order
  const ILBigInt = BigInt('0x' + bytesToHex(IL))
  const childPrivateKey =
    (ILBigInt + BigInt('0x' + parentPrivateKey)) % secp256k1.CURVE.n

  return {
    childPrivateKey: childPrivateKey.toString(16).padStart(64, '0'),
    childChainCode: bytesToHex(IR)
  }
}
```
