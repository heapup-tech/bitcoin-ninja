---
title: Runes
draft: true
---

Runes 协议由 [Casey Rodarmor](https://x.com/rodarmor) 于比特币第四次减半区块高度 840000 正式发布。并发文表示, 如果 Runes 生态上线一个月达不到10亿美元市值将切腹自尽。

:::note

Etch:

https://mempool.space/testnet/tx/2ea9caa744cf5d371960d3531f7f2fb432babedb4102598ed7d898dcd2aa0a0f

https://mempool.space/testnet/tx/009462cd78e9500d69f4d22322d1d68857864b150eac954c27d69d2efebbbe16

:::

:::note

Mint:

https://mempool.space/testnet/tx/1ce9669c2d8ce23cc38bf3ccfe9ec34523af61399db1e2313e9baf88d4266938

https://mempool.space/testnet/tx/46ad977c2c75860f675fbdf5dc4985cc604de3a93f827e0d07a626f27258e374

:::

数据存储在 `OP_RETURN` 中

```rust
let hex_string = "01000000000101b278668ba22304e8fa9f60137eb22734a307648a2eb50686d8984617bb4e95130300000000ffffffff04220200000000000022512099933aaf8f604bcca931f5d785db96dfb760ab23fbdcc634a159c7a16533504c0000000000000000096a5d0614c0a23314370008000000000000160014e5cb2de82fd4c136218c67a310fde879344c1bef1e2402000000000022512099933aaf8f604bcca931f5d785db96dfb760ab23fbdcc634a159c7a16533504c014016fbd97a208e985559eacb89b1ca13984db91efb4b1d5884f09c5adcb25e465b354690b7364f3f74c50fbd0956a2c5bdae42da51fc9680e46ae5ffebd49dd00c00000000";

Transaction { version: Version(1), lock_time: 0 blocks, input: [TxIn { previous_output: OutPoint { txid: 13954ebb174698d88606b52e8a6407a33427b27e13609ffae80423a28b6678b2, vout: 3 }, script_sig: Script(), sequence: Sequence(0xffffffff), witness: Witness: { indices: 1, indices_start: 65, witnesses: [[0x16, 0xfb, 0xd9, 0x7a, 0x20, 0x8e, 0x98, 0x55, 0x59, 0xea, 0xcb, 0x89, 0xb1, 0xca, 0x13, 0x98, 0x4d, 0xb9, 0x1e, 0xfb, 0x4b, 0x1d, 0x58, 0x84, 0xf0, 0x9c, 0x5a, 0xdc, 0xb2, 0x5e, 0x46, 0x5b, 0x35, 0x46, 0x90, 0xb7, 0x36, 0x4f, 0x3f, 0x74, 0xc5, 0x0f, 0xbd, 0x09, 0x56, 0xa2, 0xc5, 0xbd, 0xae, 0x42, 0xda, 0x51, 0xfc, 0x96, 0x80, 0xe4, 0x6a, 0xe5, 0xff, 0xeb, 0xd4, 0x9d, 0xd0, 0x0c]] } }], output: [TxOut { value: 546 SAT, script_pubkey: Script(OP_PUSHNUM_1 OP_PUSHBYTES_32 99933aaf8f604bcca931f5d785db96dfb760ab23fbdcc634a159c7a16533504c) }, TxOut { value: 0 SAT, script_pubkey: Script(OP_RETURN OP_PUSHNUM_13 OP_PUSHBYTES_6 14c0a2331437) }, TxOut { value: 2048 SAT, script_pubkey: Script(OP_0 OP_PUSHBYTES_20 e5cb2de82fd4c136218c67a310fde879344c1bef) }, TxOut { value: 140318 SAT, script_pubkey: Script(OP_PUSHNUM_1 OP_PUSHBYTES_32 99933aaf8f604bcca931f5d785db96dfb760ab23fbdcc634a159c7a16533504c) }] }
========================================
[]
========================================
Some(Runestone(Runestone { edicts: [], etching: None, mint: Some(RuneId { block: 840000, tx: 55 }), pointer: None }))
========================================
{
  "inscriptions": [],
  "runestone": {
    "Runestone": {
      "edicts": [],
      "etching": null,
      "mint": "840000:55",
      "pointer": null
    }
  }
}
```

Runestone - Rune 协议的消息格式， 存储在交易中

```rust
pub struct Runestone {
  pub edicts: Vec<Edict>,
  pub etching: Option<Etching>,
  pub mint: Option<RuneId>,
  pub pointer: Option<u32>,
}
```

部署符文

```rust
pub struct Etching {
  pub divisibility: Option<u8>,
  pub premine: Option<u128>,  // 预挖
  pub rune: Option<Rune>, // 符文名称
  pub spacers: Option<u32>, // 名称分隔符
  pub symbol: Option<char>, // 缩写
  pub terms: Option<Terms>, // 铸造规则
  pub turbo: bool,
}
```

```rust
pub struct Terms {
  pub amount: Option<u128>,
  pub cap: Option<u128>,
  pub height: (Option<u64>, Option<u64>),
  pub offset: (Option<u64>, Option<u64>),
}
```

转账指令

```rust
#[derive(Debug, PartialEq)]
pub struct Runestone {
    pub edicts: Vec<Edict>,         // 转账指令列表
    pub etching: Option<Etching>,   // 铸造信息
    pub pointer: Option<u32>,       // 默认输出指针
}

// 转账指令
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct Edict {
    pub id: RuneId,     // Rune ID
    pub amount: u128,   // 转账金额
    pub output: u32,    // 目标输出索引
}

// 铸造信息
#[derive(Debug, PartialEq)]
pub struct Etching {
    pub rune: Rune,             // Rune 属性
    pub premine: Option<u128>,  // 预挖数量
}
```

`Runestone` 是一个用于解析和处理比特币交易中特殊数据的结构，主要用于处理 Runes 协议的数据编码。

交易解码 `crates/ordinals/src/runestone.rs`

```rust
pub fn decipher(transaction: &Transaction) -> Option<Artifact> {
    // 1. 解析 payload
    // 2. 解析整数数组
    // 3. 解析消息结构
    // 4. 解析标志和字段
    // 5. 构建结果
}
```

```rust
pub(super) fn index_runes(&mut self, tx_index: u32, tx: &Transaction, txid: Txid) -> Result<()> {
    // 解析交易中 Runestone 数据
    let artifact = Runestone::decipher(tx);

    // 获取未分配的 rune 余额
    let mut unallocated = self.unallocated(tx)?;

    // // 为每个交易输出创建一个空的分配映射
    let mut allocated: Vec<HashMap<RuneId, Lot>> = vec![HashMap::new(); tx.output.len()];

    if let Some(artifact) = &artifact {
      // 处理铸造操作
      if let Some(id) = artifact.mint() {
        if let Some(amount) = self.mint(id)? {
          // 更新未分配余额
          *unallocated.entry(id).or_default() += amount;

          // 发送铸造事件
          if let Some(sender) = self.event_sender {
            sender.blocking_send(Event::RuneMinted {
              block_height: self.height,
              txid,
              rune_id: id,
              amount: amount.n(),
            })?;
          }
        }
      }

      // 处理新创建的 Rune
      let etched = self.etched(tx_index, tx, artifact)?;

      if let Artifact::Runestone(runestone) = artifact {
        if let Some((id, ..)) = etched {
          // 添加预挖数量到未分配余额
          *unallocated.entry(id).or_default() +=
            runestone.etching.unwrap().premine.unwrap_or_default();
        }

        // 处理转账
        for Edict { id, amount, output } in runestone.edicts.iter().copied() {
          let amount = Lot(amount);

          // edicts with output values greater than the number of outputs
          // should never be produced by the edict parser
          let output = usize::try_from(output).unwrap();
          assert!(output <= tx.output.len());

          // // 确定 Rune ID
          let id = if id == RuneId::default() {
            let Some((id, ..)) = etched else {
              continue;
            };

            id
          } else {
            id
          };

          // 获取可用余额
          let Some(balance) = unallocated.get_mut(&id) else {
            continue;
          };

          // 分配函数
          let mut allocate = |balance: &mut Lot, amount: Lot, output: usize| {
            if amount > 0 {
              *balance -= amount;
              *allocated[output].entry(id).or_default() += amount;
            }
          };

          // 处理特殊输出情况
          if output == tx.output.len() {
            // find non-OP_RETURN outputs
            let destinations = tx
              .output
              .iter()
              .enumerate()
              .filter_map(|(output, tx_out)| {
                (!tx_out.script_pubkey.is_op_return()).then_some(output)
              })
              .collect::<Vec<usize>>();

            // 余额分配策略：
            if !destinations.is_empty() {
              if amount == 0 {
                // if amount is zero, divide balance between eligible outputs
                // 如果金额为 0，平均分配余额
                let amount = *balance / destinations.len() as u128;
                let remainder = usize::try_from(*balance % destinations.len() as u128).unwrap();

                for (i, output) in destinations.iter().enumerate() {
                  allocate(
                    balance,
                    if i < remainder { amount + 1 } else { amount },
                    *output,
                  );
                }
              } else {
                // if amount is non-zero, distribute amount to eligible outputs
                // // 如果金额不为 0，按指定金额分配
                for output in destinations {
                  allocate(balance, amount.min(*balance), output);
                }
              }
            }
          } else {
            // Get the allocatable amount
            let amount = if amount == 0 {
              *balance
            } else {
              amount.min(*balance)
            };

            allocate(balance, amount, output);
          }
        }
      }

      if let Some((id, rune)) = etched {
        self.create_rune_entry(txid, artifact, id, rune)?;
      }
    }

    let mut burned: HashMap<RuneId, Lot> = HashMap::new();

    if let Some(Artifact::Cenotaph(_)) = artifact {
      // 所有未分配的都被燃烧
      for (id, balance) in unallocated {
        *burned.entry(id).or_default() += balance;
      }
    } else {
      let pointer = artifact
        .map(|artifact| match artifact {
          Artifact::Runestone(runestone) => runestone.pointer,
          Artifact::Cenotaph(_) => unreachable!(),
        })
        .unwrap_or_default();

      // assign all un-allocated runes to the default output, or the first non
      // OP_RETURN output if there is no default
      if let Some(vout) = pointer
        .map(|pointer| pointer.into_usize())
        .inspect(|&pointer| assert!(pointer < allocated.len()))
        .or_else(|| {
          tx.output
            .iter()
            .enumerate()
            .find(|(_vout, tx_out)| !tx_out.script_pubkey.is_op_return())
            .map(|(vout, _tx_out)| vout)
        })
      {
        for (id, balance) in unallocated {
          if balance > 0 {
            *allocated[vout].entry(id).or_default() += balance;
          }
        }
      } else {
        for (id, balance) in unallocated {
          if balance > 0 {
            *burned.entry(id).or_default() += balance;
          }
        }
      }
    }

    // update outpoint balances
    // 更新输出点余额：
    let mut buffer: Vec<u8> = Vec::new();
    for (vout, balances) in allocated.into_iter().enumerate() {
      if balances.is_empty() {
        continue;
      }

      // increment burned balances
      // 处理 OP_RETURN 输出（燃烧）
      if tx.output[vout].script_pubkey.is_op_return() {
        for (id, balance) in &balances {
          *burned.entry(*id).or_default() += *balance;
        }
        continue;
      }

      // 编码和存储余额
      buffer.clear();

      let mut balances = balances.into_iter().collect::<Vec<(RuneId, Lot)>>();

      // Sort balances by id so tests can assert balances in a fixed order
      balances.sort();

      let outpoint = OutPoint {
        txid,
        vout: vout.try_into().unwrap(),
      };

      for (id, balance) in balances {
        Index::encode_rune_balance(id, balance.n(), &mut buffer);

        // 发送转账事件
        if let Some(sender) = self.event_sender {
          sender.blocking_send(Event::RuneTransferred {
            outpoint,
            block_height: self.height,
            txid,
            rune_id: id,
            amount: balance.0,
          })?;
        }
      }

      // // 更新数据库
      self
        .outpoint_to_balances
        .insert(&outpoint.store(), buffer.as_slice())?;
    }

    // increment entries with burned runes
    // // 更新燃烧记录
    for (id, amount) in burned {
      *self.burned.entry(id).or_default() += amount;

      // 发送燃烧事件
      if let Some(sender) = self.event_sender {
        sender.blocking_send(Event::RuneBurned {
          block_height: self.height,
          txid,
          rune_id: id,
          amount: amount.n(),
        })?;
      }
    }

    Ok(())
  }
```
